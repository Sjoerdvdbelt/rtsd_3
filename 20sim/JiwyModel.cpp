/**********************************************************
 * This file is generated by the 20-sim C++ Code Generator
 *
 *  file:  JiwyModel.cpp
 *  subm:  JiwyModel
 *  model: JiwyModel
 *  expmt: Jiwy-with-controller
 *  date:  January 14, 2022
 *  time:  5:33:25 PM
 *  user:  20-sim 4.8 Campus License
 *  from:  Universiteit Twente
 *  build: 4.8.4.11233
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>
/* Include the header for memcpy and memset
 * You may need to change this into <memory.h> for older compilers
 */
#include <string.h>

/* 20-sim include files */
#include "JiwyModel.h"

/* Delta margin used for end time checking */
const XXDouble c_delta = 1.0e-7;

/* this PRIVATE function sets the input variables from the input vector */
void JiwyModel::CopyInputsToVariables (XXDouble *u)
{
	/* copy the input vector to the input variables */

}

/* this PRIVATE function uses the output variables to fill the output vector */
void JiwyModel::CopyVariablesToOutputs (XXDouble *y)
{
	/* copy the output variables to the output vector */

}

JiwyModel::JiwyModel(void)
{
	m_number_constants = 0;
	m_number_parameters = 28;
	m_number_initialvalues = 8;
	m_number_variables = 32;
	m_number_states = 8;
	m_number_rates = 8;
	m_number_matrices = 0;
	m_number_unnamed = 0;

	/* the variable arrays */
	m_C = new XXDouble[0 + 1];		/* constants */
	m_P = new XXDouble[28 + 1];		/* parameters */
	m_I = new XXDouble[8 + 1];		/* initial values */
	m_V = new XXDouble[32 + 1];		/* variables */
	m_s = new XXDouble[8 + 1];		/* states */
	m_R = new XXDouble[8 + 1];		/* rates (or new states) */
	m_M = new XXMatrix[0 + 1];		/* matrices */
	m_U = new XXDouble[0 + 1];		/* unnamed */
	m_workarray = new XXDouble[0 + 1];

	Reset(0.0);
	m_finish_time = 8.0;
}

void JiwyModel::Reset(XXDouble starttime)
{
	m_start_time = starttime;
	m_step_size = 0.001;
	m_time = starttime;
	m_major = true;
	m_stop_run = false;

	/* Clear the allocated variable memory */
	memset(m_C, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_P, 0, (28 + 1) * sizeof(XXDouble));
	memset(m_I, 0, (8 + 1) * sizeof(XXDouble));
	memset(m_V, 0, (32 + 1) * sizeof(XXDouble));
	memset(m_s, 0, (8 + 1) * sizeof(XXDouble));
	memset(m_R, 0, (8 + 1) * sizeof(XXDouble));
	memset(m_M, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_U, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_workarray, 0, (0 + 1) * sizeof(XXDouble));

	/* Clear the timeevent storage memory */
	memset(m_time_event, 0, m_timeevent_size * sizeof(XXDouble));

	state = initialrun;
}

bool JiwyModel::IsFinished(void)
{
	return (state == finished);
}

JiwyModel::~JiwyModel(void)
{
	/* free memory */
	delete[] m_C;
	delete[] m_P;
	delete[] m_I;
	delete[] m_V;
	delete[] m_s;
	delete[] m_R;
	delete[] m_M;
	delete[] m_U;
	delete[] m_workarray;
}

/* the initialization function for submodel */
void JiwyModel::Initialize (XXDouble *u, XXDouble *y, XXDouble t)
{
	/* initialization phase (allocating memory) */
	m_initialize = true;
	m_stop_run = false;

	/* set the constants */


	/* set the parameters */
	m_P[0] = 0.3;		/* ControllerPan\PID_Pan\kp {} */
	m_P[1] = 0.1;		/* ControllerPan\PID_Pan\tauD {s} */
	m_P[2] = 0.1;		/* ControllerPan\PID_Pan\beta {} */
	m_P[3] = 1000.0;		/* ControllerPan\PID_Pan\tauI {s} */
	m_P[4] = 0.2;		/* ControllerTilt\PID_Tilt\kp {} */
	m_P[5] = 0.2;		/* ControllerTilt\PID_Tilt\tauD {s} */
	m_P[6] = 0.1;		/* ControllerTilt\PID_Tilt\beta {} */
	m_P[7] = 1000.0;		/* ControllerTilt\PID_Tilt\tauI {s} */
	m_P[8] = 1.0;		/* Plant\BeltPan\r */
	m_P[9] = 0.25;		/* Plant\BeltTilt\r */
	m_P[10] = 2.0e-4;		/* Plant\DcamPan\r */
	m_P[11] = 1.0e-4;		/* Plant\DcamTilt\r */
	m_P[12] = 1.77e-6;		/* Plant\DmotPan\r */
	m_P[13] = 4.0e-7;		/* Plant\DmotTilt\r */
	m_P[14] = 0.05263157894736842;		/* Plant\GearPan\r */
	m_P[15] = 0.05263157894736842;		/* Plant\GearTilt\r */
	m_P[16] = 3.0e-4;		/* Plant\JcamPan\i */
	m_P[17] = 4.5e-5;		/* Plant\JcamTilt\i */
	m_P[18] = 2.06e-7;		/* Plant\JmotPan\i */
	m_P[19] = 5.28e-8;		/* Plant\JmotTilt\i */
	m_P[20] = 0.018;		/* Plant\MotorPan\r */
	m_P[21] = 0.00701;		/* Plant\MotorTilt\r */
	m_P[22] = 1.0;		/* SequencePan\PulsePan\start_time {s} */
	m_P[23] = 5.0;		/* SequencePan\PulsePan\stop_time {s} */
	m_P[24] = 0.1;		/* SequencePan\PulsePan\amplitude {} */
	m_P[25] = 2.0;		/* SequenceTilt\PulseTilt\start_time {s} */
	m_P[26] = 6.0;		/* SequenceTilt\PulseTilt\stop_time {s} */
	m_P[27] = -0.1;		/* SequenceTilt\PulseTilt\amplitude {} */


	/* set the initial values */
	m_I[0] = 0.0;		/* ControllerPan\PID_Pan\pdstate_initial */
	m_I[1] = 0.0;		/* ControllerPan\PID_Pan\pistate_initial */
	m_I[2] = 0.0;		/* ControllerTilt\PID_Tilt\pdstate_initial */
	m_I[3] = 0.0;		/* ControllerTilt\PID_Tilt\pistate_initial */
	m_I[4] = 0.0;		/* Plant\JmotPan\state_initial */
	m_I[5] = 0.0;		/* Plant\JmotTilt\state_initial */
	m_I[6] = 0.0;		/* Plant\ThetaPan\q_initial {rad} */
	m_I[7] = 0.0;		/* Plant\ThetaTilt\q_initial {rad} */


	/* set the states */
	m_s[0] = m_I[0];		/* ControllerPan\PID_Pan\pdstate */
	m_s[1] = m_I[1];		/* ControllerPan\PID_Pan\pistate */
	m_s[2] = m_I[2];		/* ControllerTilt\PID_Tilt\pdstate */
	m_s[3] = m_I[3];		/* ControllerTilt\PID_Tilt\pistate */
	m_s[4] = m_I[4];		/* Plant\JmotPan\state */
	m_s[5] = m_I[5];		/* Plant\JmotTilt\state */
	m_s[6] = m_I[6];		/* Plant\ThetaPan\q {rad} */
	m_s[7] = m_I[7];		/* Plant\ThetaTilt\q {rad} */


	/* set the matrices */


	/* (re-)initialize the integration method */
	myintegmethod.Initialize(this);
	
	/* copy the inputs */
	m_time = t;
	CopyInputsToVariables (u);

	/* calculate initial and static equations */
	CalculateInitial ();
	CalculateStatic ();
	CalculateInput ();
	CalculateDynamic ();
	CalculateOutput ();

	/* Set the outputs */
	CopyVariablesToOutputs (y);

	/* end of initialization phase */
	m_initialize = false;

	state = mainrun;
}

/* the function that calculates the submodel */
void JiwyModel::Calculate (XXDouble *u, XXDouble *y /*, XXDouble t*/)
{
	switch (state)
	{
		case initialrun:	/* calculate the model for the first time */
			Initialize(u, y, 0.0);
			break;
		case mainrun:	/* calculate the model */
			if ( ( m_time <= (m_finish_time - m_step_size  + c_delta )) || ( m_finish_time == 0.0 ) )
			{
				/* another precessor submodel could determine the parameters of this submodel
				   and therefore the static parameter calculations need to be performed. */
				CalculateStatic ();
				CopyInputsToVariables (u);
				CalculateInput ();
				myintegmethod.Step();
				CalculateOutput ();
				CopyVariablesToOutputs (y);
			}
			else
			{
				state = finished;
			}

			if ( ( m_stop_run == true ) || (( m_finish_time != 0.0 ) && ( m_time + c_delta >= m_finish_time)) )
			{
				state = finished;
			}
			break;
		case finished:
			break;
		default:
			break;
	}
}

/* the termination function for submodel */
void JiwyModel::Terminate (XXDouble *u, XXDouble *y /*, XXDouble t */)
{
	/* copy the inputs */
	CopyInputsToVariables (u);

	/* calculate the final model equations */
	CalculateFinal ();

	/* set the outputs */
	CopyVariablesToOutputs (y);
}


/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void JiwyModel::CalculateInitial (void)
{

}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void JiwyModel::CalculateStatic (void)
{

}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void JiwyModel::CalculateInput (void)
{

}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void JiwyModel::CalculateDynamic (void)
{
	/* Plant\JmotPan\p.f = Plant\JmotPan\state / Plant\JmotPan\i; */
	m_V[16] = m_s[4] / m_P[18];

	/* Plant\JmotTilt\p.f = Plant\JmotTilt\state / Plant\JmotTilt\i; */
	m_V[17] = m_s[5] / m_P[19];

	/* SequencePan\PulsePan\change = timeevent (SequencePan\PulsePan\start_time) or timeevent (SequencePan\PulsePan\stop_time); */
	m_V[25] = XXTimeEvent (m_P[22], 0) || XXTimeEvent (m_P[23], 1);

	/* SequencePan\PulsePan\output = SequencePan\PulsePan\amplitude * (step (SequencePan\PulsePan\start_time) - step (SequencePan\PulsePan\stop_time)); */
	m_V[24] = m_P[24] * (XXStep (m_P[22], m_time) - XXStep (m_P[23], m_time));

	/* SequenceTilt\PulseTilt\change = timeevent (SequenceTilt\PulseTilt\start_time) or timeevent (SequenceTilt\PulseTilt\stop_time); */
	m_V[27] = XXTimeEvent (m_P[25], 2) || XXTimeEvent (m_P[26], 3);

	/* SequenceTilt\PulseTilt\output = SequenceTilt\PulseTilt\amplitude * (step (SequenceTilt\PulseTilt\start_time) - step (SequenceTilt\PulseTilt\stop_time)); */
	m_V[26] = m_P[27] * (XXStep (m_P[25], m_time) - XXStep (m_P[26], m_time));

	/* ControllerPan\PlusMinus1\output = SequencePan\PulsePan\output - Plant\ThetaPan\q; */
	m_V[2] = m_V[24] - m_s[6];

	/* ControllerTilt\PlusMinus\output = SequenceTilt\PulseTilt\output - Plant\ThetaTilt\q; */
	m_V[5] = m_V[26] - m_s[7];

	/* Plant\MotorPan\p1.e = Plant\MotorPan\r * Plant\JmotPan\p.f; */
	m_V[18] = m_P[20] * m_V[16];

	/* Plant\MotorTilt\p1.e = Plant\MotorTilt\r * Plant\JmotTilt\p.f; */
	m_V[20] = m_P[21] * m_V[17];

	/* ControllerPan\PID_Pan\pdout = ControllerPan\PID_Pan\pdstate + ((ControllerPan\PID_Pan\kp * ControllerPan\PlusMinus1\output) / ControllerPan\PID_Pan\beta); */
	m_V[1] = m_s[0] + ((m_P[0] * m_V[2]) / m_P[2]);

	/* ControllerPan\PID_Pan\pirate = ControllerPan\PID_Pan\pdout / ControllerPan\PID_Pan\tauI; */
	m_R[1] = m_V[1] / m_P[3];

	/* ControllerPan\PID_Pan\output = ControllerPan\PID_Pan\pistate + ControllerPan\PID_Pan\pdout; */
	m_V[0] = m_s[1] + m_V[1];

	/* ControllerTilt\PID_Tilt\pdout = ControllerTilt\PID_Tilt\pdstate + ((ControllerTilt\PID_Tilt\kp * ControllerTilt\PlusMinus\output) / ControllerTilt\PID_Tilt\beta); */
	m_V[4] = m_s[2] + ((m_P[4] * m_V[5]) / m_P[6]);

	/* ControllerTilt\PID_Tilt\pirate = ControllerTilt\PID_Tilt\pdout / ControllerTilt\PID_Tilt\tauI; */
	m_R[3] = m_V[4] / m_P[7];

	/* ControllerTilt\PID_Tilt\output = ControllerTilt\PID_Tilt\pistate + ControllerTilt\PID_Tilt\pdout; */
	m_V[3] = m_s[3] + m_V[4];

	/* Plant\DmotPan\p.e = Plant\DmotPan\r * Plant\JmotPan\p.f; */
	m_V[10] = m_P[12] * m_V[16];

	/* Plant\DmotTilt\p.e = Plant\DmotTilt\r * Plant\JmotTilt\p.f; */
	m_V[11] = m_P[13] * m_V[17];

	/* Plant\GearPan\p2.f = Plant\GearPan\r * Plant\JmotPan\p.f; */
	m_V[13] = m_P[14] * m_V[16];

	/* Plant\GearTilt\p2.f = Plant\GearTilt\r * Plant\JmotTilt\p.f; */
	m_V[15] = m_P[15] * m_V[17];

	/* ControllerPan\PID_Pan\pdrate = (ControllerPan\PID_Pan\kp * ControllerPan\PlusMinus1\output - ControllerPan\PID_Pan\pdout) / (ControllerPan\PID_Pan\beta * ControllerPan\PID_Pan\tauD); */
	m_R[0] = (m_P[0] * m_V[2] - m_V[1]) / (m_P[2] * m_P[1]);

	/* ControllerTilt\PID_Tilt\pdrate = (ControllerTilt\PID_Tilt\kp * ControllerTilt\PlusMinus\output - ControllerTilt\PID_Tilt\pdout) / (ControllerTilt\PID_Tilt\beta * ControllerTilt\PID_Tilt\tauD); */
	m_R[2] = (m_P[4] * m_V[5] - m_V[4]) / (m_P[6] * m_P[5]);

	/* Plant\ThetaPan\p1.omega = Plant\BeltPan\r * Plant\GearPan\p2.f; */
	m_R[6] = m_P[8] * m_V[13];

	/* Plant\ThetaTilt\p1.omega = Plant\BeltTilt\r * Plant\GearTilt\p2.f; */
	m_R[7] = m_P[9] * m_V[15];

	/* Plant\MotorPan\p2.e = Plant\MotorPan\r * ControllerPan\PID_Pan\output; */
	m_V[19] = m_P[20] * m_V[0];

	/* Plant\MotorTilt\p2.e = Plant\MotorTilt\r * ControllerTilt\PID_Tilt\output; */
	m_V[21] = m_P[21] * m_V[3];

	/* Plant\DcamPan\p.e = Plant\DcamPan\r * Plant\ThetaPan\p1.omega; */
	m_V[8] = m_P[10] * m_R[6];

	/* Plant\DcamTilt\p.e = Plant\DcamTilt\r * Plant\ThetaTilt\p1.omega; */
	m_V[9] = m_P[11] * m_R[7];

	/* Plant\JcamPan\p.T_in = ((Plant\BeltPan\r * (Plant\GearPan\r * (((Plant\MotorPan\p2.e - Plant\DmotPan\p.e) - Plant\GearPan\r * (Plant\BeltPan\r * Plant\DcamPan\p.e)) / Plant\JmotPan\i))) * Plant\JcamPan\i) / (1.0 + (Plant\BeltPan\r * (Plant\GearPan\r * ((Plant\GearPan\r * Plant\BeltPan\r) / Plant\JmotPan\i))) * Plant\JcamPan\i); */
	m_V[30] = ((m_P[8] * (m_P[14] * (((m_V[19] - m_V[10]) - m_P[14] * (m_P[8] * m_V[8])) / m_P[18]))) * m_P[16]) / (1.0 + (m_P[8] * (m_P[14] * ((m_P[14] * m_P[8]) / m_P[18]))) * m_P[16]);

	/* Plant\JcamTilt\p.T_in = ((Plant\BeltTilt\r * (Plant\GearTilt\r * (((Plant\MotorTilt\p2.e - Plant\DmotTilt\p.e) - Plant\GearTilt\r * (Plant\BeltTilt\r * Plant\DcamTilt\p.e)) / Plant\JmotTilt\i))) * Plant\JcamTilt\i) / (1.0 + (Plant\BeltTilt\r * (Plant\GearTilt\r * ((Plant\GearTilt\r * Plant\BeltTilt\r) / Plant\JmotTilt\i))) * Plant\JcamTilt\i); */
	m_V[31] = ((m_P[9] * (m_P[15] * (((m_V[21] - m_V[11]) - m_P[15] * (m_P[9] * m_V[9])) / m_P[19]))) * m_P[17]) / (1.0 + (m_P[9] * (m_P[15] * ((m_P[15] * m_P[9]) / m_P[19]))) * m_P[17]);

	/* Plant\JcamPan\state = Plant\ThetaPan\p1.omega * Plant\JcamPan\i; */
	m_V[28] = m_R[6] * m_P[16];

	/* Plant\JcamTilt\state = Plant\ThetaTilt\p1.omega * Plant\JcamTilt\i; */
	m_V[29] = m_R[7] * m_P[17];

	/* Plant\OneJunction3\p3.T = Plant\DcamPan\p.e + Plant\JcamPan\p.T_in; */
	m_V[22] = m_V[8] + m_V[30];

	/* Plant\OneJunction4\p3.T = Plant\DcamTilt\p.e + Plant\JcamTilt\p.T_in; */
	m_V[23] = m_V[9] + m_V[31];

	/* Plant\BeltPan\p1.e = Plant\BeltPan\r * Plant\OneJunction3\p3.T; */
	m_V[6] = m_P[8] * m_V[22];

	/* Plant\BeltTilt\p1.e = Plant\BeltTilt\r * Plant\OneJunction4\p3.T; */
	m_V[7] = m_P[9] * m_V[23];

	/* Plant\GearPan\p1.e = Plant\GearPan\r * Plant\BeltPan\p1.e; */
	m_V[12] = m_P[14] * m_V[6];

	/* Plant\GearTilt\p1.e = Plant\GearTilt\r * Plant\BeltTilt\p1.e; */
	m_V[14] = m_P[15] * m_V[7];

	/* Plant\JmotPan\p.e = (Plant\MotorPan\p2.e - Plant\DmotPan\p.e) - Plant\GearPan\p1.e; */
	m_R[4] = (m_V[19] - m_V[10]) - m_V[12];

	/* Plant\JmotTilt\p.e = (Plant\MotorTilt\p2.e - Plant\DmotTilt\p.e) - Plant\GearTilt\p1.e; */
	m_R[5] = (m_V[21] - m_V[11]) - m_V[14];

}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void JiwyModel::CalculateOutput (void)
{

}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void JiwyModel::CalculateFinal (void)
{

}



bool JiwyModel::SetFinishTime(XXDouble newtime)
{
	if ((newtime <= 0.0) || ( newtime > m_time))
	{
		m_finish_time = newtime;
		return true;
	}

	return false;
}

XXBoolean JiwyModel::XXTimeEvent (XXDouble argument, XXInteger id)
{
	const XXDouble xx_epsilon_time = 0.001 * 1.0e-6;
	if (m_major)
	{
		XXDouble prevValue = m_time_event[id];
		m_time_event[id] = m_time;
		if ((m_time >= argument - xx_epsilon_time) && (prevValue < argument))
		{
			return XXTRUE;
		}
	}
	return XXFALSE;
}

